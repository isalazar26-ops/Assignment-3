A stack is the right choice for implementing undo/redo because it naturally models Last-In-First-Out (LIFO) behavior: the most recent user action is the first to be undone. Each performed action is pushed onto the undo stack; an undo operation pops the top action and moves it to the redo stack. This straightforward flow mirrors user expectations (undo the last edit first), and redoing simply reverses that transfer. Using two stacks (undo and redo) allows us to preserve both the history of performed actions and the ability to reapply undone actions in correct order. 

A queue is better suited for the help desk because it models First-In-First-Out (FIFO) behavior: customers should be served in the order they arrived. Enqueue adds customers to the rear; dequeue removes from the front. This guarantees fairness and predictable ordering, which is essential for customer service systems. 

My implementations use linked nodes rather than Python lists to demonstrate explicit pointer management and to avoid the potential copying/resizing semantics of high-level containers. Python lists can behave like stacks or queues, but they have trade-offs: appending/popping at the end is efficient, but poping at the start (for a queue) is O(n) unless using collections.dequeue. The linked-node approach ensures O(1) enqueue and dequeue without relying on built-in abstractions, which is instructive for understanding data-structure internals and more closely resembles lower-level implementations. 

Edge cases handled: popping/dequeueing an empty structure returns None (and the CLIs print friendly messages), and resetting the redo stack upon a new action clears redo history as expected. These simple, robust behaviors make the data structures suitable for unit tests and further expansion. 
